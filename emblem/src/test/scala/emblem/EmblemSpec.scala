package emblem

import scala.reflect.runtime.universe.typeTag
import org.scalatest._
import org.scalatest.OptionValues._

/** some basic tests for emblems */
class EmblemSpec extends FlatSpec with GivenWhenThen with Matchers {

  case class Point(x: Double, y: Double) extends HasEmblem

  object PointEmblem extends Emblem[Point](
    "emblem.EmblemSpec",
    "Point",
    Seq(
      new EmblemProp[Point, Double]("x", _.x, (p, x) => p.copy(x = x)),
      new EmblemProp[Point, Double]("y", _.y, (p, y) => p.copy(y = y))
    )
  ) {

    // TODO: these should be generated by def macro
    lazy val x = apply[Double]("x")
    lazy val y = apply[Double]("y")
  }

  behavior of "an emblem"

  it should "retain name information" in {
    PointEmblem.namePrefix should equal ("emblem.EmblemSpec")
    PointEmblem.name should equal ("Point")
    PointEmblem.fullname should equal ("emblem.EmblemSpec.Point")
  }

  it should "retain type information" in {
    PointEmblem.typeTag should equal (typeTag[Point])
  }

  it should "dump helpful debug info" in {
    PointEmblem.debugInfo should equal (
      """|emblem.EmblemSpec.Point {
         |  x: Double
         |  y: Double
         |}""".stripMargin)
  }

  val point = Point(3.0, 4.0)

  it should "allow getter access through the props" in {
    PointEmblem[Double]("x").get(point) should equal (3.0)
    PointEmblem[Double]("y").get(point) should equal (4.0)
  }

  it should "allow setter access through the props" in {
    PointEmblem[Double]("x").set(point, 5.0) should equal (Point(5.0, 4.0))
    PointEmblem[Double]("y").set(point, 5.0) should equal (Point(3.0, 5.0))
  }

  it should "allow getter access through accessors" in {
    PointEmblem.x.get(point) should equal (3.0)
    PointEmblem.y.get(point) should equal (4.0)
  }

  it should "allow setter access through accessors" in {
    PointEmblem.x.set(point, 5.0) should equal (Point(5.0, 4.0))
    PointEmblem.y.set(point, 5.0) should equal (Point(3.0, 5.0))
  }

}
